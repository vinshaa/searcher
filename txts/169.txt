Rust (programming language)                    From Wikipedia, the free encyclopedia                            Jump to:     navigation,      search            This article relies too much on references to primary sources. Please improve this article by adding secondary or tertiary sources. (January 2012) RustParadigmMulti-paradigm: compiled, concurrent, functional, imperative, object-oriented, structuredDesigned byOriginally Graydon Hoare, then Rust Project DevelopersDeveloperRust Project DevelopersFirst appeared2010Stable release1.2.0[1][2] / August 7, 2015; 13 days ago (2015-08-07)Typing disciplinestatic, strong, inferred, nominal, linearImplementation languageRustOSLinux, OS X, Windows, FreeBSD, Android, iOS (partial)[3]LicenseApache License 2.0 or MIT License[4]Filename extensions.rs, .rlibWebsitewww.rust-lang.orgInfluenced byAlef,[5] C#,[5] C++,[5] Cyclone,[5][6] Erlang,[5] Haskell,[5] Hermes,[5] Limbo,[5] Newsqueak,[5] NIL,[5] OCaml,[5] Ruby,[5] Scheme,[5] Standard ML,[5] Swift[5][7]InfluencedC# 7,[8] Elm,[9] Idris,[10] Swift[11] Rust is a general-purpose, multi-paradigm, compiled programming language developed by Mozilla Research.[12] It is designed to be a "safe, concurrent, practical language",[13][14] supporting pure-functional, concurrent-actor[dubious – discuss][citation needed], imperative-procedural, and object-oriented styles. The language grew out of a personal project by Mozilla employee Graydon Hoare. Mozilla began sponsoring the project in 2009[15] and announced it for the first time in 2010.[16] The same year, work shifted from the initial compiler (written in OCaml) to the self-hosting compiler written in Rust.[17] Known as rustc, it successfully compiled itself in 2011.[18] The self-hosted compiler uses LLVM as its back end. The first numbered pre-alpha release of the Rust compiler occurred in January 2012.[19] Rust 1.0, the first stable release, was released on May 15, 2015.[1] Rust is developed entirely in the open and solicits feedback and contributions from the community. The design of the language has been refined through the experiences of writing the Servo[20] layout engine and the Rust compiler. Although its development is sponsored by Mozilla, it is a community project. A large portion of current commits are from community members.[21]    Contents  1 Design2 Syntax3 History4 Name origin5 See also6 References7 External links   Design[edit] The goal of Rust is to be a good language for creating highly concurrent and highly safe systems.[22] This has led to a feature set with an emphasis on safety, control of memory layout, and concurrency. Performance of safe code is expected to be slower than C++ if performance is the only consideration but to be comparable to C++ code that manually takes precautions comparable to what the Rust language mandates.[23] The syntax of Rust is similar to C and C++, with blocks of code delimited by curly brackets, and control flow keywords such as if, else, while, and for. Not all C or C++ keywords are present, however, while others (such as the match keyword for multi-directional branching, similar to switch in other languages) will be less familiar to programmers coming from these languages. Despite the syntactic resemblance, Rust is semantically very different from C and C++. The system is designed to be memory safe, and it does not permit null pointers or dangling pointers.[24][25] Data values can only be initialized through a fixed set of forms, all of which require their inputs to be already initialized.[26] A system of pointer lifetimes and freezing allows the compiler to prevent many types of errors that are possible to write in C++, even when using its smart pointers. The type system supports a mechanism similar to type classes, called 'traits', inspired directly by the Haskell language. This is a facility for ad-hoc polymorphism, achieved by adding constraints to type variable declarations. Other features from Haskell, such as higher-kinded polymorphism, are not yet supported. Rust does not use an automated garbage collection system like Java or .Net. Rust features type inference, for variables declared with the let keyword. Such variables do not require a value to be initially assigned in order to determine their type. A compile time error results if any branch of code fails to assign a value to the variable.[27] Functions can be given generic parameters but they must be explicitly bounded by traits. There is no way to leave off type signatures while still making use of methods and operators on the parameters. The object system within Rust is based around implementations, traits and structured types. Implementations fulfill a role similar to that of classes within other languages, and are defined with the impl keyword. Inheritance and polymorphism are provided by traits; they allow methods to be defined and mixed in to implementations. Structured types are used to define fields. Implementations and traits cannot define fields themselves, and only traits can provide inheritance, in order to prevent the diamond inheritance problem of C++. Syntax[edit]   This section may need to be rewritten entirely to comply with Wikipedia's quality standards. You can help. The discussion page may contain suggestions. (October 2014) Hello world:   fn main() {     println!("hello, world"); }  Three versions of the factorial function, in recursive, iterative, and iterator styles:   // The branches in this function exhibit Rust's optional implicit return // values, which can be utilized where a more "functional" style is preferred. // Unlike C++ and related languages, Rust's `if` construct is an expression // rather than a statement, and thus has a return value of its own. fn recursive_factorial(n: u32) -> u32 {     if n <= 1 {         1     } else {         n * recursive_factorial(n - 1)     } }  fn iterative_factorial(n: u32) -> u32 {     // Variables are declared with `let`.     // The `mut` keyword allows these variables to be mutated.     let mut i = 1u32;     let mut result = 1u32;     while i <= n {         result *= i;         i += 1;     }     return result; // An explicit return, in contrast to the prior function. }  fn iterator_factorial(n: u32) -> u32 {     // Iterators have a variety of methods for transformations.     // |accum, x| defines an anonymous function.     // Optimizations like inline expansion reduce the range and fold     // to have performance similar to iterative_factorial.     (1..n + 1).fold(1, |accum, x| accum * x) }  fn main() {     println!("Recursive result: {}", recursive_factorial(10));     println!("Iterative result: {}", iterative_factorial(10));     println!("Iterator result: {}", iterator_factorial(10)); }  A simple demonstration of Rust's concurrency capabilities:   use std::thread;  // This function creates ten threads that all execute concurrently. // To verify this, run the program several times and observe the irregular // order in which each thread's output is printed. fn main() {     // This string is immutable, so it can safely be accessed from multiple threads.     let greeting = "Hello";      let mut threads = Vec::new();     // `for` loops work with any type that implements the `Iterator` trait.     for num in 0..10 {         threads.push(thread::spawn(move || {             // `println!` is a macro that statically typechecks a format string.             // Macros are structural (as in Scheme) rather than textual (as in C).             println!("{} from thread number {}", greeting, num);         }));     }      // Join each thread so that they all finish before program exit.     for thread in threads {         thread.join().unwrap();     } }  A demonstration of Rust's built-in unique smart pointers, along with tagged unions and methods:   use IntList::{Node, Empty};  // This program defines a recursive data structure and implements methods upon it. // Recursive data structures require a layer of indirection, which is provided here // by a unique pointer, constructed via the `Box::new` constructor. These are // analogous to the C++ library type `std::unique_ptr`, though with more static // safety guarantees. fn main() {     let list = IntList::new().prepend(3).prepend(2).prepend(1);     println!("Sum of all values in the list: {}.", list.sum());     println!("Sum of all doubled values in the list: {}.", list.multiply_by(2).sum()); }  // `enum` defines a tagged union that may be one of several different kinds of values at runtime. // The type here will either contain no value, or a value and a pointer to another `IntList`. enum IntList {     Node(i32, Box<IntList>),     Empty }  // An `impl` block allows methods to be defined on a type. impl IntList {     fn new() -> Box<IntList> {         Box::new(Empty)     }      fn prepend(self, value: i32) -> Box<IntList> {         Box::new(Node(value, Box::new(self)))     }      fn sum(&self) -> i32 {         // `match` expressions are the typical way of employing pattern-matching,         // and are somewhat analogous to the `switch` statement from C and C++.         match *self {             Node(value, ref next) => value + next.sum(),             Empty => 0         }     }      fn multiply_by(&self, n: i32) -> Box<IntList> {         match *self {             Node(value, ref next) => Box::new(Node(value * n, next.multiply_by(n))),             Empty => Box::new(Empty)         }     } }  History[edit] In addition to conventional static typing, prior to version 0.4 Rust also supported typestates. The typestate system modeled assertions before and after program statements, through use of a special check statement. Discrepancies could be discovered at compile time, rather than once a program was running, as might be the case with assertions in C or C++ code. The typestate concept was not unique to Rust, as it was first introduced in the NIL programming language.[28] Typestates were removed because in practice they found little use, though the same functionality can still be achieved with branding patterns.[29] The style of the object system changed considerably within versions 0.2, 0.3 and 0.4 of Rust. Version 0.2 introduced classes for the first time, with version 0.3 adding a number of features including destructors and polymorphism through the use of interfaces. In Rust 0.4, traits were added as a means to provide inheritance; interfaces were unified with traits and removed as a separate feature. Classes were also removed, replaced by a combination of implementations and structured types. Starting in Rust 0.9 and ending in Rust 0.11, Rust had two built-in pointer types, ~ and @, simplifying the core memory model. It reimplemented those pointer types in the standard library as Box and (the now removed) Gc. The first "stable" version of the Rust, version 1.0.0, was released 2015-05-15.[30] Name origin[edit] The name "Rust" originates from the fungi of the same name.[31] See also[edit] Comparison of programming languagesServo (layout engine)Swift (programming language) References[edit]  ^ a b "rust/RELEASES.md at master · rust-lang/rust · GitHub". GitHub. ^ "Announcing Rust 1.2". ^ "Doc building for ios". GitHub. Retrieved 4 January 2015. ^ "COPYRIGHT". Rust compiler source repository. Retrieved 2012-12-17. ^ a b c d e f g h i j k l m n o "The Rust Reference: Appendix: Influences". Retrieved March 25, 2015. Rust is not a particularly original language, with design elements coming from a wide range of sources. Some of these are listed below (including elements that have since been removed): SML, OCaml [...] C++ [...] ML Kit, Cyclone [...] Haskell [...] Newsqueak, Alef, Limbo [...] Erlang [...] Swift [...] Scheme [...] C# [...] Ruby [...] NIL, Hermes ^ "Note Research: Type System". 2015-02-01. Retrieved 2015-03-25. Papers that have had more or less influence on Rust, or which one might want to consult for inspiration or to understand Rust's background. [...] Region based memory management in Cyclone [...] Safe memory management in Cyclone ^ "RFC for `if let` expression". Retrieved December 4, 2014. The `if let` construct is based on the precedent set by Swift, which introduced its own `if let` statement. ^ "Discussion - Patterns and Records". 2015-03-25. Retrieved 2015-03-25. Sources of Inspiration: [...] Rust ^ "Command Optimizations?". 2014-06-26. Retrieved 2014-12-10. I just added the outline of a Result library that lets you use richer error messages. It's like Either except the names are more helpful. The names are inspired by Rust's Result library. ^ "Uniqueness Types". 2014-08-22. Retrieved 2014-10-27. They are inspired by linear types, Uniqueness Types in the Clean programming language, and ownership types and borrowed pointers in the Rust programming language. ^ Lattner, Chris (2014-06-03). "Chris Lattner's Homepage". Chris Lattner. Retrieved 2014-06-03. The Swift language is the product of tireless effort from a team of language experts, documentation gurus, compiler optimization ninjas, and an incredibly important internal dogfooding group who provided feedback to help refine and battle-test ideas. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list. ^ Noel (2010-07-08). "The Rust Language". Lambda the Ultimate. Retrieved 2010-10-30. ^ "The Rust Programming Language". Retrieved 2012-10-21. ^ "Doc language FAQ". Retrieved 2012-10-21. ^ "Project FAQ". 2010-09-14. Retrieved 2012-01-11. ^ "Future Tense". 2011-04-29. Retrieved 2012-02-06. At Mozilla Summit 2010, we launched Rust, a new programming language motivated by safety and concurrency for parallel hardware, the “manycore” future which is upon us. ^ Hoare, Graydon (2010-10-02). "Rust Progress". Retrieved 2010-10-30. ^ Hoare, Graydon (2011-04-20). "[rust-dev] stage1/rustc builds". Retrieved 2011-04-20. After that last change fixing the logging scope context bug, looks like stage1/rustc builds. Just shy of midnight :) ^ catamorphism (2012-01-20). "Mozilla and the Rust community release Rust 0.1 (a strongly-typed systems programming language with a focus on memory safety and concurrency)". Retrieved 2012-02-06. ^ Peter Bright (2013-04-03). "Samsung teams up with Mozilla to build browser engine for multicore machines". Retrieved 2013-04-04. ^ "Rust Contributors". ^ Avram, Abel (2012-08-03). "Interview on Rust, a Systems Programming Language Developed by Mozilla". InfoQ. Retrieved 2013-08-17. GH: A lot of obvious good ideas, known and loved in other languages, haven't made it into widely used systems languages... There were a lot of good competitors in the late 1970s and early 1980s in that space, and I wanted to revive some of their ideas and give them another go, on the theory that circumstances have changed: the internet is highly concurrent and highly security-conscious, so the design-tradeoffs that always favor C and C++ (for example) have been shifting. ^ Walton, Patrick (2010-12-05). "C++ Design Goals in the Context of Rust". Retrieved 2011-01-21. ... It’s impossible to be “as fast as C” in all cases while remaining safe... C++ allows all sorts of low-level tricks, mostly involving circumventing the type system, that offer practically unlimited avenues for optimization. In practice, though, C++ programmers restrict themselves to a few tools for the vast majority of the code they write, including stack-allocated variables owned by one function and passed by alias, uniquely owned objects (often used with auto_ptr or the C++0x unique_ptr), and reference counting via shared_ptr or COM. One of the goals of Rust’s type system is to support these patterns exactly as C++ does, but to enforce their safe usage. In this way, the goal is to be competitive with the vast majority of idiomatic C++ in performance, while remaining memory-safe... ^ Rosenblatt, Seth (2013-04-03). "Samsung joins Mozilla's quest for Rust". Retrieved 2013-04-05. [Brendan Eich] noted that every year browsers fall victim to hacking in the annual Pwn2Own contest at the CanSecWest conference. "There's no free memory reads" in Rust, he said, but there are in C++. Those problems "lead to a lot of browser vulnerabilities" and would be solved by Rust, which is a self-compiling language. ^ Brown, Neil (2013-04-17). "A taste of Rust". Retrieved 2013-04-25. ... Other more complex data structures could clearly be implemented to allow greater levels of sharing, while making sure the interface is composed only of owned and managed references, and thus is safe from unplanned concurrent access and from dangling pointer errors. ^ "Doc language FAQ". 2010-09-14. Retrieved 2012-01-11. ^ Walton, Patrick (2010-10-01). "Rust Features I: Type Inference". Retrieved 2011-01-21. ^ Strom, Robert E.; Yemini, Shaula (1986). "Typestate: A Programming Language Concept for Enhancing Software Reliability" (PDF). IEEE Transactions on Software Engineering. ISSN 0098-5589. Retrieved 2010-11-14. ^ "Typestate Is Dead, Long Live Typestate!". 2012-12-26. Retrieved 2012-12-28. ^ http://static.rust-lang.org/dist/index.html^ "Internet archaeology: the definitive, end-all source for why Rust is named "Rust"".   External links[edit] Official websiteThe Rust-dev Archives (electronic mailing list)Primary source code repository and bug trackerRust projectsRust Rosetta - implementations of common algorithms and solutionsRust by Example - web book    vte  Mozilla     Projects   Mozilla Labs  BonsaiBugzillaChatZillaElectrolysis ProjectJetpackLightningPenelopePersonaPrismRaindropSkywriterSunbirdSyncTinderboxUbiquity  Mozilla Research  Firefox OSOpenFlintRustServo  Mozilla Foundation    Firefox 11.5233.53.645–currentFuture releasesfor Mobilefor iOS SeaMonkeyThunderbird  Origins  Mozilla Application SuiteNetscape NavigatorNetscape CommunicatorNetscape CommunicationsBeonex Communicator  Forks  BurningDogClassillaFlockGnuzillaIceapeIceCatIcedoveIceowlMiroNetscape 9Portable EditionSwiftfoxSwiftweaselTenFourFoxxB Browser  Frameworks  add-onGeckoNeckoNPAPI XPConnect XBLXPCOMXPInstallXULXULRunner  Components  Application Object ModelComposerNSPRNSSRhinoSpiderMonkeyTamarinVenkman  Discontinued  Calendar ProjectCaminoFirefox HomeGrendelMinimo         Organization   Foundation  Former Mozilla OrganizationMozilla Foundation  Subsidiaries  Mozilla CorporationMozilla MessagingMozilla Online  Official affiliates  Mozilla ChinaMozilla EuropeMozilla JapanMozilla Taiwan  People  Mitchell BakerBrendan Eich        Community   mozdev.orgMozilla Add-onsMozilla Developer NetworkMozillaZineSpread Firefox       Misc.   The Book of MozillaMozilla Public Licenserebranding / forkingmascotCode RushMozilla localizations                        Retrieved from "https://en.wikipedia.org/w/index.php?title=Rust_(programming_language)&oldid=676983124"          Categories: Rust (programming language)Systems programming languagesConcurrent programming languagesStatically typed programming languagesMulti-paradigm programming languagesFunctional languagesProcedural programming languagesPattern matching programming languagesMozillaProgramming languages created in 2012Software using the Apache licenseSoftware using the MIT licenseHidden categories: Articles lacking reliable references from January 2012All articles lacking reliable referencesAll accuracy disputesArticles with disputed statements from May 2015All articles with unsourced statementsArticles with unsourced statements from May 2015Wikipedia articles needing rewrite from October 2014Official website different in Wikidata and Wikipedia                      Navigation menu                      Personal tools       Create accountLog in                                  Namespaces       ArticleTalk                                      Variants                                                                     Views       ReadEditView history                        More                                                       Search                                                                                     Navigation               Main pageContentsFeatured contentCurrent eventsRandom articleDonate to WikipediaWikipedia store                   Interaction               HelpAbout WikipediaCommunity portalRecent changesContact page                   Tools               What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationWikidata itemCite this page                   Print/export               Create a bookDownload as PDFPrintable version                   Languages               DeutschEspa?olEsperanto?????Français???ItalianoNederlands???PolskiPortugu?s???????SvenskaTürkçe????????????     Edit links                          This page was last modified on 20 August 2015, at 10:46.Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.        Privacy policyAbout WikipediaDisclaimersContact WikipediaDevelopersMobile view